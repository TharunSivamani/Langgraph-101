# Langgraph-101

## Typed Annotations

### Dictionary

```python
movie = {"name": "Avengers Endgame", "year": 2019}
```

### Typed Dictionary

```python
from typing import TypedDict

class Movie(TypedDict):
    name: str
    year: int

movie = Movie(name="Avenger Endgame", year=2019)
```

### Union

```python
from typing import Union

def square(x: Union[int, float]) -> float:
    return x * x

x = 5
x = 1.234
x = "I am a string" # Error
```

### Optional

```python
from typing import Optional

def greet(msg: Optional[str]):
    return f"Msg: {msg}"
```

### Any

```python
from typing import Any

def pprintt(x: Any):
    print(x)
```

### Lambda

```python
square = lambda x: x * x

nums = [1, 2, 3, 4, 5]
sq = list(map(lambda x: x * x, nums))
```
<br>
<br>

# 🌐 LangGraph Concepts Overview

LangGraph is a framework for building and executing AI-driven workflows. Below are the key components that define its architecture and behavior.

---

## 🧠 State

**State** is a shared data structure that holds the current information or context of the entire application.  
It is continuously updated and passed between nodes during execution.

---

## 🧩 Node

**Nodes** are individual functions or operations that perform specific tasks within the graph.

Each node typically:
- Receives input (often from the current state),
- Processes it,
- Produces an output or an updated state.

---

## 🔗 Graph

The **Graph** is the overarching structure that defines how nodes are connected and executed.

It maps out the **workflow**, including:
- The sequence of operations,
- Conditional logic,
- Execution flow between tasks.

---

## ➡️ Edges

**Edges** are the connections between nodes that determine the execution path.  
They define **what node to execute next** after the current one completes its task.

---

## 🔀 Conditional Edges

**Conditional Edges** are specialized edges that determine the next node based on certain conditions or logic applied to the current state.  
They enable **dynamic branching** within the workflow.

---

## 🚦 START

The **START** node is a virtual entry point in LangGraph.

- Marks the beginning of the workflow.
- Does not perform any operations.
- Serves as the designated starting point for graph execution.

---

## 🛑 END

The **END** node signifies the conclusion of the workflow.

- When this node is reached, the graph execution stops.
- Indicates that all intended tasks have been completed.

---

## 🛠️ Tools

**Tools** are specialized functions or utilities that nodes can use to perform specific tasks, such as fetching data from an API.

- Enhance node capabilities.
- Provide additional, often external, functionality.
- Are invoked from within nodes but are not nodes themselves.

---

## 🔧 Tool Node

A **ToolNode** is a special type of node designed to execute a tool.

- It runs the associated tool.
- Integrates the tool’s output back into the state.
- Allows other nodes to use the updated state.

---

## 🗺️ StateGraph

**StateGraph** is a class in LangGraph used to build and compile the graph structure.

- Manages nodes, edges, and state.
- Ensures proper data flow and execution.
- Provides tools to validate and execute the graph.

---

## ⚙️ Runnable

A **Runnable** is a standardized, executable component that performs a specific task in an AI workflow.

- Core building block of LangGraph.
- Allows modular design and reusability.

---

## 💬 Messages

LangGraph supports various types of messages to facilitate communication:

1. **Human Message** – Input from a human user.
2. **AI Message** – Response generated by the AI.
3. **System Message** – Instructions or metadata that guide system behavior.
4. **Tool Message** – Output generated by a tool.
5. **Function Message** – Result of executing a function or callable.

---
